{% extends "base.html" %}

{% block content %}
<!-- Add Marked.js for Markdown parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- Add Highlight.js for code syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- Stili per i messaggi di token nella chat -->
<style>
    .token-message {
        font-size: 12px;
        color: #666;
        text-align: right;
        margin: 5px 0;
        font-style: italic;
    }
    
    /* Message Styling */
    .message {
        padding: 12px;
        margin: 8px 0;
        border-radius: 8px;
        max-width: 80%;
        white-space: pre-wrap;
        word-break: break-word;
    }

    /* Markdown Styling */
    .bot-message h1,
    .bot-message h2,
    .bot-message h3,
    .bot-message h4,
    .bot-message h5,
    .bot-message h6 {
        margin-top: 16px;
        margin-bottom: 8px;
        font-weight: 600;
        line-height: 1.25;
    }

    .bot-message h1 { font-size: 1.5em; }
    .bot-message h2 { font-size: 1.3em; }
    .bot-message h3 { font-size: 1.1em; }

    .bot-message p {
        margin: 8px 0;
    }

    .bot-message ul,
    .bot-message ol {
        margin: 8px 0;
        padding-left: 24px;
    }

    .bot-message li {
        margin: 4px 0;
    }

    .bot-message code {
        padding: 2px 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-family: monospace;
    }

    .bot-message pre {
        margin: 8px 0;
        padding: 12px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 8px;
        overflow-x: auto;
    }

    .bot-message pre code {
        padding: 0;
        background: transparent;
    }

    .bot-message a {
        color: #58a6ff;
        text-decoration: none;
    }

    .bot-message a:hover {
        text-decoration: underline;
    }

    .bot-message blockquote {
        margin: 8px 0;
        padding-left: 12px;
        border-left: 3px solid rgba(255, 255, 255, 0.3);
        color: rgba(255, 255, 255, 0.8);
    }

    .user-message {
        background: #f3f4f6;
        margin-left: auto;
    }

    .bot-message {
        background: #000;
        color: #fff;
        margin-right: auto;
    }

    /* Loading Animation */
    .loading-dots {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 12px 16px;
        background: #000;
        border-radius: 8px;
        margin: 8px 0;
        margin-right: auto;
        max-width: 80px;
    }

    .loading-dots span {
        width: 6px;
        height: 6px;
        background: #fff;
        border-radius: 50%;
        animation: bounce 1.4s infinite ease-in-out;
        opacity: 0.7;
    }

    .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
    .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

    @keyframes bounce {
        0%, 80%, 100% { transform: scale(0); }
        40% { transform: scale(1); }
    }

    /* Scrollbar Styling */
    .overflow-y-auto::-webkit-scrollbar {
        width: 6px;
    }

    .overflow-y-auto::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
    }

    .overflow-y-auto::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 3px;
    }

    .overflow-y-auto::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    /* Message Styling */
    .message {
        max-width: 80%;
        padding: 1rem;
        border-radius: 1rem;
        margin: 0.5rem 0;
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.5;
    }

    .user-message {
        background-color: #e2e8f0;
        margin-left: auto;
        color: #1a202c;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .bot-message {
        background-color: #f8fafc;
        margin-right: auto;
        color: #2d3748;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        border: 1px solid #e2e8f0;
    }

    /* Chat History Item Styling */
    .chat-history-item {
        padding: 0.75rem;
        border-bottom: 1px solid #e2e8f0;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .chat-history-item:hover {
        background-color: #f8fafc;
    }

    .chat-history-item.active {
        background-color: #e2e8f0;
        font-weight: 500;
    }

    /* Loading and Error Messages */
    .loading-message {
        text-align: center;
        padding: 2rem;
        color: #4a5568;
        font-style: italic;
    }

    .error-message {
        text-align: center;
        padding: 2rem;
        color: #e53e3e;
        background-color: #fff5f5;
        border: 1px solid #fc8181;
        border-radius: 0.5rem;
        margin: 1rem;
    }
</style>
<div id="notifications-container" class="fixed top-5 right-5 z-50 flex flex-col gap-3 w-80"></div>

<div class="max-w-7xl mx-auto px-4">
    <!-- Header con titolo e link al tutorial -->
    <div class="w-[1200px] mx-auto py-2 px-6 mb-0">
        <div class="flex items-center gap-4">
            <!-- Piccolo grafico di chat -->
          <div class="w-14 h-14 rounded-lg flex items-center justify-center p-1.5">
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" class="w-full h-full">
                      <!-- Icona chat stilizzata -->
                    <rect x="10" y="20" width="80" height="60" rx="8" fill="none" stroke="#000" stroke-width="2"/>
                    <circle cx="30" cy="40" r="5" fill="#333"/>
                    <circle cx="50" cy="40" r="5" fill="#333"/>
                    <circle cx="70" cy="40" r="5" fill="#333"/>
                    <path d="M25 60 H75" stroke="#333" stroke-width="2"/>
                    <path d="M25 70 H60" stroke="#333" stroke-width="2"/>
                </svg>
            </div>
            <div>
                <h1 class="text-2xl font-bold mb-3 text-black">CHATBOT</h1>
                <a href="#" id="open-tutorial-modal" class="text-gray-600 hover:text-black underline transition-colors">
                    Come funziona? Apri il tutorial
                </a>
            </div>
        </div>
    </div>

    <div class="w-[1200px] h-[800px] mx-auto bg-white rounded-lg shadow-lg flex flex-col">
        <!-- Header con menu a tendina -->
        <div class="flex gap-4 p-4 bg-gray-50 rounded-t-lg border-b">
            <div class="flex-1">
                <div class="relative">
                    <select id="grade-select" class="w-full p-3 pl-4 pr-10 border-0 rounded-xl bg-white shadow-sm appearance-none text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all cursor-pointer">
                        <option value="" disabled selected>Grado scolastico</option>
                        <option value="sec1">Scuola Sec. I grado</option>
                        <option value="sec2-biennio">Scuola Sec. II grado - Biennio</option>
                        <option value="sec2-triennio">Scuola Sec. II grado - Triennio</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                        <svg class="w-4 h-4 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"></path>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="flex-1">
                <div class="relative">
                    <select id="mode-select" class="w-full p-3 pl-4 pr-10 border-0 rounded-xl bg-white shadow-sm appearance-none text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all cursor-pointer">
                        <option value="" disabled selected>Modalità</option>
                        <option value="interrogazione">Modalità Interrogazione</option>
                        <option value="interazione">Modalità Interazione</option>
                        <option value="intervista">Modalità Intervista Impossibile</option>
                        <option value="rag">Modalità RAG (Analisi Documenti)</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                        <svg class="w-4 h-4 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"></path>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="flex-1">
                <div class="relative">
                    <select id="subject-select" class="w-full p-3 pl-4 pr-10 border-0 rounded-xl bg-white shadow-sm appearance-none text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all cursor-pointer">
                        <option value="" disabled selected>Argomento</option>
                        <option value="ai">AI</option>
                        <option value="scienze">Scienze</option>
                        <option value="storia">Storia</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                        <svg class="w-4 h-4 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"></path>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="flex-1">
                <div class="relative">
                    <select id="model-select" class="w-full p-3 pl-4 pr-10 border-0 rounded-xl bg-white shadow-sm appearance-none text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all cursor-pointer">
                        <option value="" disabled selected>Modello AI</option>
                        <option value="gpt4o-mini">GPT-4 O Mini</option>
                        <option value="o3-mini">O3 Mini</option>
                        <option value="o3-mini-reasoning">O3 Mini con Ragionamento</option>
                        <option value="gemini">Gemini Flash</option>
                        <option value="ollama">Ollama</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                        <svg class="w-4 h-4 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"></path>
                        </svg>
                    </div>
                </div>
                <div class="relative mt-2">
                    <select id="ollama-models-select" class="w-full p-3 pl-4 pr-10 border-0 rounded-xl bg-white shadow-sm appearance-none text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all cursor-pointer hidden">
                        <option value="" disabled selected>Seleziona modello Ollama</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500 hidden" id="ollama-select-arrow">
                        <svg class="w-4 h-4 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"></path>
                        </svg>
                    </div>
                </div>
                <div id="ollama-status" class="text-sm mt-2 px-2 py-1 rounded-lg hidden font-medium"></div>
            </div>
        </div>

        <!-- Context Area -->
        <div class="p-4 bg-gray-50 border-b">
            <div class="flex gap-2">
                <textarea id="context-input" 
                           class="flex-1 p-3 border-0 rounded-xl resize-none bg-white shadow-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all" 
                           rows="3" 
                           placeholder="Descrivi la personalità del bot e il modo in cui dovrà esserti utile...."></textarea>
                <button onclick="submitContext()" 
                        class="px-5 py-3 bg-[#2c2063] text-white rounded-xl hover:bg-[#1c1043] self-end transition-colors shadow-sm">
                    Inizia
                </button>
            </div>
            <div id="interview-questions" class="mt-3 hidden">
                <div class="text-sm text-gray-600 mb-2">Per l'intervista impossibile, rispondi a queste domande:</div>
                <div class="space-y-2">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Quale personaggio vuoi che interpreti?</label>
                        <input type="text" id="character-input" class="mt-1 p-2 w-full border rounded bg-white">
                    </div>
                    <div class="flex gap-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="historical-accuracy" class="mr-2">
                            <label class="text-sm text-gray-700">Comportamento storico accurato</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="period-language" class="mr-2">
                            <label class="text-sm text-gray-700">Linguaggio d'epoca</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- RAG Documents Area -->
            <div id="rag-documents" class="mt-3 hidden">
                <div class="text-sm text-gray-600 mb-2">Seleziona i documenti da analizzare:</div>
                <div class="flex flex-wrap gap-2 mb-3" id="selected-files-container">
                    <!-- I file selezionati verranno visualizzati qui -->
                    <div class="text-sm text-gray-500 italic">Nessun file selezionato</div>
                </div>
                <button id="select-files-btn" class="px-3 py-1.5 bg-[#2c2063] text-white rounded hover:bg-[#1c1043] text-sm flex items-center">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                    </svg>
                    Seleziona Risorse
                </button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex flex-1 overflow-hidden">
            <!-- Chat History Sidebar -->
            <div class="w-1/4 border-r bg-gray-50 flex flex-col">
                <div class="p-3 border-b space-y-2">
                    <button onclick="startNewChat()" 
                            class="w-full px-4 py-3 bg-[#2c2063] text-white rounded-xl hover:bg-[#1c1043] transition-colors shadow-sm">
                        Nuova Chat
                    </button>
                    <button onclick="clearAllChats()" 
                            class="w-full px-4 py-3 border border-[#2c2063] text-[#2c2063] rounded-xl hover:bg-[#f0eef7] transition-colors flex items-center justify-center gap-2 shadow-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                        Elimina Tutto
                    </button>
                </div>
                <div id="chat-history" class="flex-1 overflow-y-auto">
                    <!-- Chat history items will be populated here -->
                </div>
            </div>

            <!-- Chat Area -->
            <div class="flex-1 flex flex-col">
                <!-- Messages Container -->
                <div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-4">
                    <!-- Messages will be populated here -->
                </div>

                <!-- Input Area -->
                <div class="p-4 border-t bg-white">
                    <div class="flex gap-2">
                        <textarea id="message-input" 
                                  class="flex-1 p-3 border-0 rounded-xl resize-none shadow-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-[#FF385C] transition-all"
                                  placeholder="Finestra di input: >"
                                  rows="1"></textarea>
                        <button onclick="downloadChat()" 
                                class="px-3 py-3 border border-[#2c2063] text-[#2c2063] rounded-xl hover:bg-[#1c1043] transition-colors flex items-center justify-center shadow-sm"
                                title="Scarica chat">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <button onclick="sendMessage()" 
                                class="px-5 py-3 bg-[#FF385C] text-white rounded-xl hover:bg-[#E0314F] transition-colors shadow-sm">
                            Invia
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal per la selezione dei file -->
<div id="file-select-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg w-full max-w-4xl max-h-[80vh] flex flex-col">
        <div class="px-6 py-4 border-b flex justify-between items-center">
            <h3 class="text-lg font-semibold">Seleziona Risorse</h3>
            <button id="close-file-modal" class="text-gray-500 hover:text-gray-700">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
        <div class="p-4 border-b">
            <div class="relative">
                <input type="text" id="modal-search-files" placeholder="Cerca file..." class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-black focus:border-transparent">
                <svg class="absolute left-3 top-2.5 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
            </div>
            <div class="flex flex-wrap gap-2 mt-2">
                <button data-filter="all" class="file-filter-btn px-3 py-1 text-sm bg-black text-white rounded-full">Tutti</button>
                <button data-filter="image" class="file-filter-btn px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-full">Immagini</button>
                <button data-filter="document" class="file-filter-btn px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-full">Documenti</button>
                <button data-filter="csv" class="file-filter-btn px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-full">CSV</button>
                <button data-filter="text" class="file-filter-btn px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-full">Testo</button>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto p-4" id="modal-files-container">
            <!-- I file verranno caricati qui dinamicamente -->
            <div class="text-center py-10 text-gray-500">Caricamento file in corso...</div>
        </div>
        <div class="px-6 py-4 border-t flex justify-end">
            <button id="confirm-file-selection" class="px-4 py-2 bg-[#2c2063] text-white rounded-md hover:bg-[#1c1043] transition-colors">
                Conferma selezione
            </button>
        </div>
    </div>
</div>

<!-- Modale Tutorial -->
<div id="tutorial-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg max-w-3xl w-full mx-4 max-h-[90vh] overflow-y-auto">
        <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold text-gray-800">Tutorial: Chatbot</h2>
                <button id="close-tutorial-modal" class="text-gray-400 hover:text-gray-600 focus:outline-none">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="p-6 space-y-6">
            <!-- Immagine esplicativa -->
            <div class="bg-gray-50 p-4 rounded-lg shadow-inner flex justify-center">
                <svg viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg" class="w-full max-w-md h-40">
                    <!-- Illustrazione chatbot -->
                    <rect x="20" y="10" width="160" height="80" rx="10" fill="#f3f4f6" stroke="#333" stroke-width="2"/>
                    <rect x="30" y="25" width="80" height="20" rx="5" fill="#e2e8f0"/>
                    <rect x="90" y="55" width="80" height="20" rx="5" fill="#000"/>
                    <text x="40" y="40" font-size="10" fill="#333">Utente</text>
                    <text x="100" y="70" font-size="10" fill="#fff">Assistente AI</text>
                </svg>
            </div>
            
            <div class="space-y-6">
                <!-- Cos'è il chatbot -->
                <div class="bg-white rounded-lg p-5 border border-gray-200 shadow-sm">
                    <h3 class="flex items-center text-lg font-semibold text-gray-800 mb-3">
                        <svg class="w-5 h-5 mr-2 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                        Cos'è il Chatbot?
                    </h3>
                    <div class="text-sm text-gray-600 space-y-2">
                        <p>Il chatbot è un assistente virtuale basato su intelligenza artificiale che può rispondere alle tue domande, aiutarti con compiti specifici e fornire informazioni su vari argomenti.</p>
                        <p>Utilizza modelli di linguaggio avanzati per comprendere il contesto delle tue richieste e generare risposte pertinenti e utili.</p>
                        <p>Puoi interagire con il chatbot in linguaggio naturale, proprio come faresti in una conversazione con un'altra persona.</p>
                    </div>
                </div>
                
                <!-- Come usare lo strumento -->
                <div class="bg-white rounded-lg p-5 border border-gray-200 shadow-sm">
                    <h3 class="flex items-center text-lg font-semibold text-gray-800 mb-3">
                        <svg class="w-5 h-5 mr-2 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/>
                        </svg>
                        Come usare questo strumento
                    </h3>
                    <ol class="text-sm text-gray-600 space-y-2 ml-5 list-decimal">
                        <li><strong>Seleziona il modello</strong>: Scegli il modello di intelligenza artificiale più adatto alle tue esigenze dal menu a tendina.</li>
                        <li><strong>Fornisci contesto</strong>: Se necessario, puoi inserire un contesto specifico per aiutare il chatbot a comprendere meglio le tue richieste.</li>
                        <li><strong>Scrivi il tuo messaggio</strong>: Inserisci la tua domanda o richiesta nella casella di testo in basso.</li>
                        <li><strong>Invia e attendi</strong>: Clicca su "Invia" o premi Enter e attendi la risposta del chatbot.</li>
                        <li><strong>Conversazione continua</strong>: Continua la conversazione aggiungendo nuovi messaggi. Il chatbot manterrà il contesto della conversazione.</li>
                    </ol>
                </div>
            </div>
        </div>
        
        <div class="p-6 border-t border-gray-200 flex justify-end">
            <button id="close-tutorial-btn" class="px-4 py-2 bg-[#2c2063] text-white rounded-md hover:bg-[#1c1043] transition-colors">
                Chiudi tutorial
            </button>
        </div>
    </div>
</div>

<script>
    let currentChatId = null;
    let chatMessages = [];

    // Initialize event listeners
    document.addEventListener('DOMContentLoaded', function() {
        loadChatHistory();
        setupEventListeners();
        // Disable message input initially
        document.getElementById('message-input').disabled = true;
        // Enable context input
        document.getElementById('context-input').disabled = false;
    });

    function setupEventListeners() {
        // Handle enter key in message input
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
            messageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
        }

        // Handle enter key in context input
        const contextInput = document.getElementById('context-input');
        if (contextInput) {
            contextInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    submitContext(e);
                }
            });

            // Clean up pasted text
            contextInput.addEventListener('paste', function(e) {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text');
                const cleaned = text.replace(/[\r\n]+/g, ' ').trim();
                document.execCommand('insertText', false, cleaned);
            });
        }

        // Handle mode selection change
        const modeSelect = document.getElementById('mode-select');
        if (modeSelect) {
            modeSelect.addEventListener('change', function() {
                const contextInput = document.getElementById('context-input');
                const messageInput = document.getElementById('message-input');
                const interviewQuestions = document.getElementById('interview-questions');
                const ragDocuments = document.getElementById('rag-documents');
                
                if (this.value === 'interrogazione') {
                    contextInput.placeholder = 'Descrivi l\'argomento specifico su cui vuoi essere interrogato...';
                    messageInput.disabled = true;
                    contextInput.disabled = false;
                    interviewQuestions.classList.add('hidden');
                    ragDocuments.classList.add('hidden');
                } else if (this.value === 'intervista') {
                    contextInput.placeholder = 'Informazioni aggiuntive sul personaggio e il contesto storico (opzionale)...';
                    messageInput.disabled = true;
                    contextInput.disabled = false;
                    interviewQuestions.classList.remove('hidden');
                    ragDocuments.classList.add('hidden');
                } else if (this.value === 'rag') {
                    contextInput.placeholder = 'Inserisci una domanda o un compito specifico per analizzare i documenti selezionati...';
                    messageInput.disabled = true;
                    contextInput.disabled = false;
                    interviewQuestions.classList.add('hidden');
                    ragDocuments.classList.remove('hidden');
                } else {
                    contextInput.placeholder = 'Descrivi la personalità del bot e il modo in cui dovrà esserti utile....';
                    messageInput.disabled = true;
                    contextInput.disabled = false;
                    interviewQuestions.classList.add('hidden');
                    ragDocuments.classList.add('hidden');
                }
            });
        }
        
        // Gestione del pulsante per selezionare i file
        const selectFilesBtn = document.getElementById('select-files-btn');
        if (selectFilesBtn) {
            selectFilesBtn.addEventListener('click', function() {
                openFileSelectModal();
            });
        }
        
        // Gestione della chiusura della finestra modale
        const closeFileModal = document.getElementById('close-file-modal');
        if (closeFileModal) {
            closeFileModal.addEventListener('click', function() {
                document.getElementById('file-select-modal').classList.add('hidden');
            });
        }
        
        // Gestione della conferma della selezione dei file
        const confirmFileSelection = document.getElementById('confirm-file-selection');
        if (confirmFileSelection) {
            confirmFileSelection.addEventListener('click', function() {
                confirmSelectedFiles();
                document.getElementById('file-select-modal').classList.add('hidden');
            });
        }
        
        // Gestione della ricerca dei file nella modale
        const modalSearchFiles = document.getElementById('modal-search-files');
        if (modalSearchFiles) {
            modalSearchFiles.addEventListener('input', function() {
                filterModalFiles(this.value);
            });
        }
        
        // Gestione dei filtri per tipo di file
        const fileFilterBtns = document.querySelectorAll('.file-filter-btn');
        fileFilterBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                // Rimuovi la classe attiva da tutti i pulsanti
                fileFilterBtns.forEach(b => {
                    b.classList.remove('bg-black', 'text-white');
                    b.classList.add('bg-gray-200', 'text-gray-700');
                });
                
                // Aggiungi la classe attiva a questo pulsante
                this.classList.remove('bg-gray-200', 'text-gray-700');
                this.classList.add('bg-black', 'text-white');
                
                // Filtra i file per tipo
                const filterType = this.getAttribute('data-filter');
                filterModalFilesByType(filterType);
            });
        });
        
        // Handle submit context button
        const submitButton = document.querySelector('button[onclick="submitContext()"]');
        if (submitButton) {
            submitButton.removeAttribute('onclick');
            submitButton.addEventListener('click', function(e) {
                e.preventDefault();
                submitContext(e);
            });
        }
        
        // Handle send message button
        const sendButton = document.querySelector('button[onclick="sendMessage()"]');
        if (sendButton) {
            sendButton.removeAttribute('onclick');
            sendButton.addEventListener('click', function(e) {
                e.preventDefault();
                sendMessage();
            });
        }
        
        // Handle model change
        const modelSelect = document.getElementById('model-select');
        if (modelSelect) {
            modelSelect.addEventListener('change', function(e) {
                updateModel(e.target.value);
            });
        }
    }

    // Funzioni per gestire la selezione dei file e l'integrazione con la modalità RAG
    let selectedFiles = [];
    
    function openFileSelectModal() {
        // Mostra la finestra modale
        document.getElementById('file-select-modal').classList.remove('hidden');
        // Carica i file disponibili
        loadAvailableFiles();
    }
    
    async function loadAvailableFiles() {
        try {
            const response = await fetch('/api/files');
            if (response.ok) {
                const data = await response.json();
                // Verifica che data.files sia un array
                if (data && Array.isArray(data.files)) {
                    renderModalFiles(data.files);
                } else {
                    console.error('Formato dati non valido:', data);
                    document.getElementById('modal-files-container').innerHTML = '<div class="text-center py-10 text-red-500">Formato dati non valido</div>';
                }
            } else {
                console.error('Errore nel caricamento dei file:', response.statusText);
                document.getElementById('modal-files-container').innerHTML = '<div class="text-center py-10 text-red-500">Errore nel caricamento dei file</div>';
            }
        } catch (error) {
            console.error('Errore nella richiesta:', error);
            document.getElementById('modal-files-container').innerHTML = '<div class="text-center py-10 text-red-500">Errore nel caricamento dei file</div>';
        }
    }
    
    function renderModalFiles(files) {
        const container = document.getElementById('modal-files-container');
        
        if (!files || files.length === 0) {
            container.innerHTML = '<div class="text-center py-10 text-gray-500">Nessun file disponibile</div>';
            return;
        }
        
        let html = '';
        files.forEach(file => {
            const isSelected = selectedFiles.some(f => f.id === file.id);
            const fileTypeClass = getFileTypeClass(file.type);
            
            html += `
            <div class="file-item p-3 border-b hover:bg-gray-50 flex items-center ${isSelected ? 'bg-gray-100' : ''}" data-file-id="${file.id}" data-file-type="${file.type}">
                <div class="mr-3 ${fileTypeClass} p-2 rounded">
                    ${getFileIcon(file.type)}
                </div>
                <div class="flex-1">
                    <div class="font-medium">${file.name}</div>
                    <div class="text-xs text-gray-500">${getReadableFileType(file.type)} · ${formatFileSize(file.size)}</div>
                </div>
                <div>
                    <input type="checkbox" class="file-select-checkbox w-5 h-5" ${isSelected ? 'checked' : ''}>
                </div>
            </div>`;
        });
        
        container.innerHTML = html;
        
        // Aggiungi event listener per la selezione dei file
        document.querySelectorAll('.file-item').forEach(item => {
            item.addEventListener('click', function(e) {
                if (e.target.classList.contains('file-select-checkbox')) {
                    return; // Lascia che il checkbox gestisca il suo stato
                }
                
                const checkbox = this.querySelector('.file-select-checkbox');
                checkbox.checked = !checkbox.checked;
                
                // Trigger change event
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            });
        });
        
        document.querySelectorAll('.file-select-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const fileItem = this.closest('.file-item');
                const fileId = fileItem.getAttribute('data-file-id');
                
                if (this.checked) {
                    fileItem.classList.add('bg-gray-100');
                    // Aggiungi il file alla selezione se non è già presente
                    if (!selectedFiles.some(f => f.id === fileId)) {
                        selectedFiles.push({
                            id: fileId,
                            name: fileItem.querySelector('.font-medium').textContent,
                            type: fileItem.getAttribute('data-file-type')
                        });
                    }
                } else {
                    fileItem.classList.remove('bg-gray-100');
                    // Rimuovi il file dalla selezione
                    selectedFiles = selectedFiles.filter(f => f.id !== fileId);
                }
            });
        });
    }
    
    function getFileTypeClass(fileType) {
        if (fileType.startsWith('image/')) {
            return 'bg-blue-100 text-blue-600';
        } else if (fileType === 'application/pdf') {
            return 'bg-red-100 text-red-600';
        } else if (fileType === 'text/csv') {
            return 'bg-green-100 text-green-600';
        } else if (fileType.startsWith('text/')) {
            return 'bg-purple-100 text-purple-600';
        } else {
            return 'bg-gray-100 text-gray-600';
        }
    }
    
    function getFileIcon(fileType) {
        if (fileType.startsWith('image/')) {
            return '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>';
        } else if (fileType === 'application/pdf') {
            return '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0112.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>';
        } else if (fileType === 'text/csv') {
            return '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg>';
        } else if (fileType.startsWith('text/')) {
            return '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>';
        } else {
            return '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4.586a1 1 0 01.707.293l4.414 4.414a1 1 0 01.293.707V19a2 2 0 01-2 2h-2M8 7H6a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2v-2"></path></svg>';
        }
    }
    
    function getReadableFileType(fileType) {
        if (fileType.startsWith('image/')) {
            return 'Immagine';
        } else if (fileType === 'application/pdf') {
            return 'PDF';
        } else if (fileType === 'text/csv') {
            return 'CSV';
        } else if (fileType.startsWith('text/')) {
            return 'Testo';
        } else {
            return 'File';
        }
    }
    
    function formatFileSize(size) {
        if (size < 1024) {
            return size + ' B';
        } else if (size < 1024 * 1024) {
            return (size / 1024).toFixed(1) + ' KB';
        } else {
            return (size / (1024 * 1024)).toFixed(1) + ' MB';
        }
    }
    
    function filterModalFiles(searchTerm) {
        const fileItems = document.querySelectorAll('.file-item');
        searchTerm = searchTerm.toLowerCase();
        
        fileItems.forEach(item => {
            const fileName = item.querySelector('.font-medium').textContent.toLowerCase();
            if (fileName.includes(searchTerm)) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    }
    
    function filterModalFilesByType(filterType) {
        const fileItems = document.querySelectorAll('.file-item');
        
        fileItems.forEach(item => {
            const fileType = item.getAttribute('data-file-type');
            
            if (filterType === 'all') {
                item.style.display = '';
            } else if (filterType === 'image' && fileType.startsWith('image/')) {
                item.style.display = '';
            } else if (filterType === 'document' && fileType === 'application/pdf') {
                item.style.display = '';
            } else if (filterType === 'csv' && fileType === 'text/csv') {
                item.style.display = '';
            } else if (filterType === 'text' && fileType.startsWith('text/') && fileType !== 'text/csv') {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    }
    
    function confirmSelectedFiles() {
        const container = document.getElementById('selected-files-container');
        
        if (selectedFiles.length === 0) {
            container.innerHTML = '<div class="text-sm text-gray-500 italic">Nessun file selezionato</div>';
            return;
        }
        
        let html = '';
        selectedFiles.forEach(file => {
            const fileTypeClass = getFileTypeClass(file.type);
            
            html += `
            <div class="file-badge flex items-center bg-gray-100 rounded px-2 py-1 text-sm">
                <span class="${fileTypeClass.split(' ')[1]} mr-1">${getFileIcon(file.type)}</span>
                <span class="mr-2">${file.name}</span>
                <button class="text-gray-500 hover:text-gray-700 remove-file" data-file-id="${file.id}">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>`;
        });
        
        container.innerHTML = html;
        
        // Aggiungi event listener per rimuovere i file
        document.querySelectorAll('.remove-file').forEach(btn => {
            btn.addEventListener('click', function() {
                const fileId = this.getAttribute('data-file-id');
                selectedFiles = selectedFiles.filter(f => f.id !== fileId);
                confirmSelectedFiles(); // Aggiorna la visualizzazione
            });
        });
    }

    async function loadChatHistory() {
        try {
            const response = await fetch('/api/chat-history');
            const history = await response.json();
            updateChatHistoryUI(history);
        } catch (error) {
            console.error('Error loading chat history:', error);
        }
    }

    function updateChatHistoryUI(history) {
        const container = document.getElementById('chat-history');
        container.innerHTML = '';

        history.forEach(chat => {
            const div = document.createElement('div');
            div.className = `chat-history-item ${chat.id === currentChatId ? 'bg-[#FFF0F2] border-l-4 border-[#FF385C]' : ''} flex justify-between items-center p-2 hover:bg-gray-100 transition-colors`;
            
            // Chat title
            const titleSpan = document.createElement('span');
            titleSpan.className = 'flex-1 cursor-pointer';
            titleSpan.textContent = chat.title || 'New Chat';
            titleSpan.onclick = () => loadChat(chat.id);
            
            // Delete button
            const deleteButton = document.createElement('button');
            deleteButton.className = 'ml-2 p-1 border border-[#FF385C] rounded-lg hover:bg-[#FFF0F2] transition-colors shadow-sm';
            deleteButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-[#FF385C]" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>`;
            deleteButton.onclick = (e) => {
                e.stopPropagation();
                deleteChat(chat.id);
            };
            
            div.appendChild(titleSpan);
            div.appendChild(deleteButton);
            container.appendChild(div);
        });
    }

    async function submitContext(event) {
        if (event) {
            event.preventDefault();
        }

        let inputs = [];
        let startButton = null;
        
        try {
            const contextInput = document.getElementById('context-input');
            const modeSelect = document.getElementById('mode-select');
            const messageInput = document.getElementById('message-input');
            
            // Special handling for interview mode
            if (modeSelect?.value === 'intervista') {
                const character = document.getElementById('character-input')?.value?.trim();
                if (!character) {
                    alert('Per favore, specifica il personaggio da interpretare.');
                    return;
                }

                const historicalAccuracy = document.getElementById('historical-accuracy').checked;
                const periodLanguage = document.getElementById('period-language').checked;
                
                // Build context for interview mode
                let interviewContext = `Interpreta il personaggio storico: ${character}.\n`;
                if (historicalAccuracy) {
                    interviewContext += 'Mantieni un comportamento accurato al periodo storico.\n';
                }
                if (periodLanguage) {
                    interviewContext += 'Usa un linguaggio tipico dell\'epoca.\n';
                }

                // Add any additional context
                const additionalContext = contextInput?.value?.trim();
                if (additionalContext) {
                    interviewContext += '\nInformazioni aggiuntive:\n' + additionalContext;
                }

                contextInput.value = interviewContext;
            } else if (modeSelect?.value === 'rag') {
                // Verifica che siano stati selezionati dei file per la modalità RAG
                if (selectedFiles.length === 0) {
                    alert('Per favore, seleziona almeno un file da analizzare.');
                    return;
                }
                
                const context = contextInput?.value?.trim() || '';
                if (!context) {
                    alert('Per favore, inserisci una domanda o un compito specifico per analizzare i documenti.');
                    return;
                }
            } else {
                const context = contextInput?.value?.trim() || '';
                if (!context) {
                    if (modeSelect?.value === 'interrogazione') {
                        alert('Per favore inserisci l\'argomento su cui vuoi essere interrogato.');
                    } else {
                        alert('Per favore descrivi la personalità del bot.');
                    }
                    return;
                }
            }

            const gradeSelect = document.getElementById('grade-select');
            const subjectSelect = document.getElementById('subject-select');
            const modelSelect = document.getElementById('model-select');
            startButton = document.querySelector('button[onclick="submitContext()"]');

            // Validate all required fields
            if (!gradeSelect?.value || !modeSelect?.value || !subjectSelect?.value || !modelSelect?.value) {
                alert('Per favore seleziona tutte le opzioni prima di iniziare.');
                return;
            }

            // Add loading animation to chat messages
            const messagesContainer = document.getElementById('chat-messages');
            if (messagesContainer) {
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'loading-dots';
                loadingDiv.innerHTML = '<span></span><span></span><span></span>';
                messagesContainer.appendChild(loadingDiv);
                // Scroll to loading animation
                loadingDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }

            // Disable inputs while processing
            inputs = [contextInput, gradeSelect, modeSelect, subjectSelect, modelSelect].filter(Boolean);
            inputs.forEach(input => input.disabled = true);
            if (startButton) startButton.disabled = true;

            let data;
            try {
                // Prepara il corpo della richiesta in base alla modalità
                // Get Ollama model if selected
                const ollamaModelsSelect = document.getElementById('ollama-models-select');
                let modelValue = modelSelect.value;
                
                // If Ollama is selected, format the model name correctly
                if (modelValue === 'ollama' && ollamaModelsSelect?.value) {
                    modelValue = `ollama:${ollamaModelsSelect.value}`;
                    console.log(`Using Ollama model: ${modelValue}`);
                }
                
                // Validate Ollama model selection
                if (modelValue === 'ollama' || (modelValue === 'ollama' && !ollamaModelsSelect?.value)) {
                    throw new Error('Seleziona un modello Ollama specifico prima di inviare un messaggio.');
                }
                
                let requestBody = {
                    message: modeSelect.value === 'interrogazione' ? 'START_INTERROGATION' :
                           modeSelect.value === 'intervista' ? 'START_INTERVIEW' : contextInput.value,
                    context: {
                        grade: gradeSelect.value,
                        mode: modeSelect.value,
                        subject: subjectSelect.value,
                        model: modelValue
                    },
                    chatId: currentChatId
                };
                
                // Aggiungi il system prompt in base alla modalità
                if (modeSelect.value === 'interrogazione') {
                    requestBody.context.systemPrompt = `Sei un insegnante di ${subjectSelect.value} che sta conducendo un\'interrogazione. L\'argomento è: ${contextInput.value}. 

IMPORTANTE: Attendi sempre la risposta dell'utente prima di procedere. NON rispondere mai alle tue stesse domande. NON simulare o inventare risposte dell'utente.

Fai domande appropriate per il livello scolastico ${gradeSelect.value}. Dopo ogni risposta dell\'utente, fornisci un feedback costruttivo, correggendo eventuali errori e incoraggiando l\'apprendimento. Poi procedi con una nuova domanda solo se l'utente ha risposto alla precedente.

Se l'utente invia "START_INTERROGATION", inizia l'interrogazione con la prima domanda. Per ogni altro messaggio dell'utente, consideralo come una risposta alla tua domanda precedente.`;
                } else if (modeSelect.value === 'intervista') {
                    requestBody.context.systemPrompt = `Sei un chatbot che interpreta un personaggio storico in un\'intervista impossibile. ${contextInput.value}. Mantieni sempre il carattere e la personalità del personaggio nelle tue risposte, tenendo conto del grado scolastico ${gradeSelect.value} e dell\'argomento ${subjectSelect.value}. Rispondi in modo coinvolgente e educativo, mantenendo la coerenza storica.`;
                } else if (modeSelect.value === 'rag') {
                    requestBody.context.systemPrompt = `Sei un assistente AI esperto nell'analisi di documenti. La tua funzione è analizzare i documenti forniti e rispondere alla seguente domanda o compito: ${contextInput.value}. Considera attentamente il contenuto di tutti i documenti forniti e fornisci una risposta completa e accurata basata esclusivamente sulle informazioni contenute nei documenti. Se le informazioni non sono sufficienti, indica chiaramente quali aspetti non possono essere determinati dai documenti forniti.`;
                    requestBody.context.files = selectedFiles.map(file => file.id);
                } else {
                    requestBody.context.systemPrompt = contextInput.value;
                }
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error('La risposta del server non è in formato JSON');
                }

                if (!response.ok) {
                    const errorData = await response.json();
                    if (errorData.error && errorData.error.includes('Claude API Error')) {
                        throw new Error('Il modello Claude non è al momento disponibile. Prova a selezionare un altro modello.');
                    } else {
                        throw new Error(errorData.error || `Errore del server: ${response.status}`);
                    }
                }

                data = await response.json();
                if (!data || !data.response) {
                    throw new Error('Risposta non valida dal server');
                }
            } catch (error) {
                console.error('Error:', error);
                if (error.message.includes('Claude API Error') || error.message.includes('Claude non è al momento disponibile')) {
                    // Switch to GPT-4 automatically
                    const modelSelect = document.getElementById('model-select');
                    if (modelSelect) {
                        modelSelect.value = 'gpt4';
                        throw new Error('Il modello Claude non è disponibile. Passaggio automatico a GPT-4. Riprova.');
                    }
                }
                throw error;
            }

            // Enable message input and disable context input
            if (messageInput) messageInput.disabled = false;
            if (contextInput) contextInput.disabled = true;
            if (startButton) startButton.style.display = 'none';

            // Remove loading animation
            const loadingDots = document.querySelector('.loading-dots');
            if (loadingDots) loadingDots.remove();

            // Update UI with bot's response
            if (data.response) {
                addMessageToUI('bot', data.response);
            }
            
            // Update chat ID if new chat
            if (data.chatId) {
                currentChatId = data.chatId;
                await loadChatHistory();
            }
        } catch (error) {
            console.error('Error:', error);
            // Remove loading animation on error
            const loadingDots = document.querySelector('.loading-dots');
            if (loadingDots) loadingDots.remove();

            addMessageToUI('error', 'Si è verificato un errore: ' + error.message);
            
            // Re-enable inputs on error
            if (inputs.length) {
                inputs.forEach(input => {
                    if (input) input.disabled = false;
                });
            }
            if (startButton) startButton.disabled = false;
        }
    }

    // Definire le soglie per i livelli di avviso del contatore di token
    const TOKEN_THRESHOLDS = {
        warning: 10000,  // 10k token - Giallo
        danger: 50000    // 50k token - Rosso
    };
    
    // Variabile per tenere traccia del totale dei token nell'intera sessione
    let sessionTokenCount = {
        total: 0,
        input: 0,
        output: 0
    };
    
    // Carica i dati dei token salvati dal localStorage all'avvio
    document.addEventListener('DOMContentLoaded', function() {
        try {
            const savedTokens = localStorage.getItem('sessionTokenCount');
            if (savedTokens) {
                sessionTokenCount = JSON.parse(savedTokens);
                console.log('Token count loaded from localStorage:', sessionTokenCount);
            }
        } catch (error) {
            console.error('Error loading token count from localStorage:', error);
        }
    });
    
    // Funzione per aggiornare il contatore dei token
    function updateTokenCounter(tokenInfo) {
        if (!tokenInfo) return;
        
        // Aggiorna il conteggio della sessione
        sessionTokenCount.total += tokenInfo.total || 0;
        sessionTokenCount.input += tokenInfo.input || 0;
        sessionTokenCount.output += tokenInfo.output || 0;
        
        // Salva nel localStorage
        localStorage.setItem('sessionTokenCount', JSON.stringify(sessionTokenCount));
        
        // Visualizza i dettagli dei token per questa risposta
        console.log('Token usage for this response:', tokenInfo);
    }
    
    // Funzione per aggiungere un messaggio di token alla chat
    function addTokenInfoToChat(tokenInfo) {
        if (!tokenInfo) return;
        
        const chatMessages = document.getElementById('chat-messages');
        const tokenMsgElem = document.createElement('div');
        tokenMsgElem.className = 'token-message';
        tokenMsgElem.innerHTML = `
            <strong>Utilizzo token:</strong> ${tokenInfo.total} totali 
            (${tokenInfo.input} input, ${tokenInfo.output} output)
        `;
        chatMessages.appendChild(tokenMsgElem);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    async function sendMessage() {
        const input = document.getElementById('message-input');
        const message = input.value.trim();
        if (!message) return;

        try {
            // Disable input and button while sending
            input.disabled = true;
            const sendButton = document.querySelector('button[onclick="sendMessage()"]');
            const downloadButton = document.querySelector('button[onclick="downloadChat()"]');
            if (sendButton) sendButton.disabled = true;
            if (downloadButton) downloadButton.disabled = true;

            // Add user message to UI
            addMessageToUI('user', message);
            input.value = '';

            // Add loading animation
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-dots';
            loadingDiv.innerHTML = '<span></span><span></span><span></span>';
            document.getElementById('chat-messages').appendChild(loadingDiv);

            // Get current context and settings
            const context = {
                grade: document.getElementById('grade-select')?.value || '',
                mode: document.getElementById('mode-select')?.value || '',
                subject: document.getElementById('subject-select')?.value || '',
                systemPrompt: document.getElementById('context-input')?.value || ''
            };
            
            // Handle Ollama model selection
            const modelSelect = document.getElementById('model-select');
            const ollamaModelsSelect = document.getElementById('ollama-models-select');
            
            if (modelSelect?.value === 'ollama' && ollamaModelsSelect?.value) {
                context.model = `ollama:${ollamaModelsSelect.value}`;
            } else {
                context.model = modelSelect?.value || 'gpt4';
            }
            
            // Validate Ollama model selection
            if (modelSelect?.value === 'ollama' && !ollamaModelsSelect?.value) {
                throw new Error('Seleziona un modello Ollama specifico prima di inviare un messaggio.');
            }

            console.log('Sending request with:', { message, context, chatId: currentChatId });

            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    message: message,
                    context: context,
                    chatId: currentChatId
                })
            });

            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                throw new Error('Server response was not JSON');
            }

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            if (data.error) {
                throw new Error(data.error);
            }

            addMessageToUI('bot', data.response);
            
            // Gestione e visualizzazione delle informazioni sui token
            if (data.token_info) {
                console.log('Token info received:', data.token_info);
                
                // Aggiorna il contatore dei token
                updateTokenCounter(data.token_info);
                
                // Aggiungi informazioni sui token alla chat
                addTokenInfoToChat(data.token_info);
            }
            
            // Update chat history if this is a new chat
            if (data.chatId !== currentChatId) {
                currentChatId = data.chatId;
                await loadChatHistory();
            }
        } catch (error) {
            console.error('Error sending message:', error);
            addMessageToUI('bot', `Si è verificato un errore: ${error.message}`);
        } finally {
            // Remove loading animation and re-enable inputs
            const loadingDots = document.querySelector('.loading-dots');
            if (loadingDots) loadingDots.remove();

            input.disabled = false;
            const sendButton = document.querySelector('button[onclick="sendMessage()"]');
            const downloadButton = document.querySelector('button[onclick="downloadChat()"]');
            if (sendButton) sendButton.disabled = false;
            if (downloadButton) downloadButton.disabled = false;
            input.focus();
        }
    }

    function addMessageToUI(role, content) {
        const container = document.getElementById('chat-messages');
        if (!container) return;

        // Remove any existing loading animation if adding a bot message
        if (role === 'bot') {
            const loadingDots = container.querySelector('.loading-dots');
            if (loadingDots) loadingDots.remove();
        }

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${role}-message`;
        
        if (role === 'bot') {
            // Formattazione speciale per la parte di pensiero del bot
            // Cerchiamo il pattern <think>...</think> nel contenuto
            const thinkRegex = /<think>([\s\S]*?)<\/think>/g;
            let formattedContent = content;
            let hasThinkingPart = thinkRegex.test(content);
            
            // Resettiamo il regex per il prossimo utilizzo
            thinkRegex.lastIndex = 0;
            
            // Se c'è una parte di pensiero, la formattiamo in piccolo e corsivo
            if (hasThinkingPart) {
                formattedContent = content.replace(thinkRegex, '<div class="bot-thinking"><i>$1</i></div>');
            }
            
            // Inizialmente aggiungiamo un div vuoto che verrà riempito gradualmente
            messageDiv.innerHTML = '<div class="typing-text"></div>';
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            // Aggiungiamo stile CSS per la parte di pensiero
            const style = document.createElement('style');
            if (!document.querySelector('style#bot-thinking-style')) {
                style.id = 'bot-thinking-style';
                style.textContent = `
                    .bot-thinking {
                        font-size: 0.85em;
                        color: #666;
                        margin-bottom: 8px;
                        padding: 8px;
                        background-color: #f5f5f5;
                        border-radius: 4px;
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Effetto di digitazione parola per parola
            const typingElement = messageDiv.querySelector('.typing-text');
            
            // Parse markdown for bot messages
            marked.setOptions({
                highlight: function(code, language) {
                    if (language && hljs.getLanguage(language)) {
                        try {
                            return hljs.highlight(code, { language }).value;
                        } catch (err) {}
                    }
                    return code;
                },
                breaks: true,
                gfm: true
            });
            
            const parsedContent = marked.parse(formattedContent);
            
            // Funzione per aggiungere il contenuto parola per parola
            typeContentWordByWord(typingElement, parsedContent);
            
            return; // Usciamo dalla funzione perché il contenuto verrà aggiunto gradualmente
        } else {
            // For user messages, just handle basic formatting
            const formattedContent = content
                .replace(/\n/g, '<br>')
                .replace(/\s{2,}/g, ' &nbsp;');
            messageDiv.innerHTML = formattedContent;
        }
        
        // Aggiungiamo il messaggio al container (solo per messaggi utente, i messaggi bot sono gestiti sopra)
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    // Funzione per aggiungere il contenuto parola per parola con effetto di digitazione
    function typeContentWordByWord(element, htmlContent) {
        // Creiamo un elemento temporaneo per estrarre il testo dall'HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlContent;
        
        // Configurazione della velocità di digitazione
        const typingSpeed = {
            minDelay: 5,  // Ridotto da 20ms a 5ms
            maxDelay: 15, // Ridotto da 50ms a 15ms
            chunkSize: 3  // Mostra 3 parole alla volta invece di una sola
        };
        
        // Funzione ricorsiva per processare i nodi
        function processNode(node, parentElement) {
            if (node.nodeType === Node.TEXT_NODE) {
                // Se è un nodo di testo, lo dividiamo in parole
                const words = node.textContent.split(/\s+/).filter(word => word.length > 0);
                
                // Se il testo è molto lungo (più di 100 parole), aumentiamo la velocità
                if (words.length > 100) {
                    typingSpeed.chunkSize = 5;  // Mostra 5 parole alla volta per testi lunghi
                    typingSpeed.minDelay = 2;  // Riduciamo ulteriormente il ritardo
                    typingSpeed.maxDelay = 8;
                }
                
                let currentIndex = 0;
                
                function typeNextChunk() {
                    if (currentIndex < words.length) {
                        // Determiniamo quante parole mostrare in questo chunk (fino a chunkSize)
                        const wordsToShow = Math.min(typingSpeed.chunkSize, words.length - currentIndex);
                        const chunk = document.createElement('span');
                        
                        // Aggiungiamo tutte le parole del chunk
                        for (let i = 0; i < wordsToShow; i++) {
                            chunk.textContent += words[currentIndex + i] + (currentIndex + i < words.length - 1 ? ' ' : '');
                        }
                        
                        parentElement.appendChild(chunk);
                        currentIndex += wordsToShow;
                        
                        // Scroll alla fine del container dopo ogni chunk
                        const container = document.getElementById('chat-messages');
                        container.scrollTop = container.scrollHeight;
                        
                        // Pausa più breve tra i chunk
                        setTimeout(typeNextChunk, Math.random() * (typingSpeed.maxDelay - typingSpeed.minDelay) + typingSpeed.minDelay);
                    } else {
                        // Quando abbiamo finito di digitare il testo, applichiamo l'evidenziazione della sintassi
                        if (parentElement.querySelectorAll) {
                            parentElement.querySelectorAll('pre code').forEach((block) => {
                                hljs.highlightElement(block);
                            });
                        }
                    }
                }
                
                if (words.length > 0) {
                    typeNextChunk();
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // Gestione speciale per i blocchi di codice e altri elementi che non dovrebbero avere l'effetto di digitazione
                if (node.tagName === 'PRE' || 
                    (node.tagName === 'CODE' && node.parentNode && node.parentNode.tagName === 'PRE') ||
                    node.tagName === 'TABLE' || node.tagName === 'IMG' || node.tagName === 'IFRAME') {
                    // Per questi elementi, li copiamo direttamente senza effetto di digitazione
                    const clonedNode = node.cloneNode(true);
                    parentElement.appendChild(clonedNode);
                    
                    // Applichiamo l'evidenziazione della sintassi per i blocchi di codice
                    if (clonedNode.tagName === 'PRE') {
                        const codeBlocks = clonedNode.querySelectorAll('code');
                        codeBlocks.forEach(block => hljs.highlightElement(block));
                    } else if (clonedNode.tagName === 'CODE') {
                        hljs.highlightElement(clonedNode);
                    }
                    return;
                }
                
                // Se è un elemento normale, creiamo un nuovo elemento dello stesso tipo
                const newElement = document.createElement(node.tagName);
                
                // Copiamo tutti gli attributi
                for (let i = 0; i < node.attributes.length; i++) {
                    const attr = node.attributes[i];
                    newElement.setAttribute(attr.name, attr.value);
                }
                
                // Aggiungiamo il nuovo elemento al parent
                parentElement.appendChild(newElement);
                
                // Processiamo ricorsivamente tutti i figli
                for (let i = 0; i < node.childNodes.length; i++) {
                    processNode(node.childNodes[i], newElement);
                }
            }
        }
        
        // Processiamo tutti i nodi di primo livello
        for (let i = 0; i < tempDiv.childNodes.length; i++) {
            processNode(tempDiv.childNodes[i], element);
        }
        
        // Smooth scroll to the latest message
        setTimeout(() => {
            const container = document.getElementById('chat-messages');
            container.scrollTop = container.scrollHeight;
        }, 100);
    }


    async function updateModel(model) {
        // Handle model change logic here
        console.log('Model changed to:', model);
        
        const ollamaModelsSelect = document.getElementById('ollama-models-select');
        const ollamaStatus = document.getElementById('ollama-status');
        const ollamaSelectArrow = document.getElementById('ollama-select-arrow');
        
        // Hide Ollama elements by default
        ollamaModelsSelect.classList.add('hidden');
        ollamaSelectArrow.classList.add('hidden');
        ollamaStatus.classList.add('hidden');
        ollamaStatus.textContent = '';
        
        // If Ollama is selected, try to fetch available models
        if (model === 'ollama') {
            ollamaModelsSelect.classList.remove('hidden');
            ollamaSelectArrow.classList.remove('hidden');
            // Only load models if we haven't loaded them recently
            const now = Date.now();
            const timeElapsed = now - lastOllamaApiRequestTime;
            if (timeElapsed > OLLAMA_API_RATE_LIMIT || ollamaModelsSelect.options.length <= 1) {
                await loadOllamaModels();
            } else {
                // Just show the dropdown without reloading
                ollamaStatus.classList.remove('hidden');
                ollamaStatus.textContent = `${ollamaModelsSelect.options.length - 1} modelli disponibili`;
                ollamaStatus.className = 'text-sm mt-2 px-2 py-1 rounded-lg bg-green-50 text-green-600 font-medium';
            }
        }
    }
    
    // Variable to track if we're currently loading Ollama models to prevent multiple simultaneous requests
    let isLoadingOllamaModels = false;
    // Timestamp of the last successful Ollama API request
    let lastOllamaApiRequestTime = 0;
    // Minimum time between Ollama API requests in milliseconds (1 second)
    const OLLAMA_API_RATE_LIMIT = 1000;
    // Variable to track if Ollama is available locally
    let isOllamaAvailableLocally = false;
    
    // Function to check if Ollama is available locally on the user's computer
    async function checkLocalOllamaAvailability() {
        const ollamaStatus = document.getElementById('ollama-status');
        
        try {
            // Show checking state
            ollamaStatus.classList.remove('hidden');
            ollamaStatus.textContent = 'Verificando Ollama sul tuo computer...';
            ollamaStatus.className = 'text-sm mt-1 text-blue-600';
            
            // Try to fetch from local Ollama API with a short timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
            
            const response = await fetch('http://localhost:11434/api/tags', {
                method: 'GET',
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
                isOllamaAvailableLocally = true;
                ollamaStatus.textContent = 'Ollama trovato sul tuo computer!';
                ollamaStatus.className = 'text-sm mt-1 text-green-600';
                
                // Load models since Ollama is available
                loadOllamaModels();
                return true;
            } else {
                throw new Error('Ollama API returned an error');
            }
        } catch (error) {
            console.error('Error checking local Ollama:', error);
            isOllamaAvailableLocally = false;
            ollamaStatus.textContent = 'Ollama non trovato sul tuo computer. Installa Ollama per utilizzare modelli locali.';
            ollamaStatus.className = 'text-sm mt-1 text-yellow-600';
            return false;
        }
    }
    
    async function loadOllamaModels() {
        const ollamaModelsSelect = document.getElementById('ollama-models-select');
        const ollamaStatus = document.getElementById('ollama-status');
        
        // If Ollama is not available locally, don't try to load models
        if (!isOllamaAvailableLocally) {
            ollamaStatus.classList.remove('hidden');
            ollamaStatus.textContent = 'Ollama non è disponibile sul tuo computer. Installa Ollama per utilizzare modelli locali.';
            ollamaStatus.className = 'text-sm mt-1 text-yellow-600';
            return;
        }
        
        // If we're already loading models, don't make another request
        if (isLoadingOllamaModels) {
            ollamaStatus.classList.remove('hidden');
            ollamaStatus.textContent = 'Caricamento modelli in corso...';
            ollamaStatus.className = 'text-sm mt-1 text-blue-600';
            return;
        }
        
        // Check if we need to wait due to rate limiting
        const now = Date.now();
        const timeElapsed = now - lastOllamaApiRequestTime;
        if (timeElapsed < OLLAMA_API_RATE_LIMIT) {
            const waitTime = OLLAMA_API_RATE_LIMIT - timeElapsed;
            ollamaStatus.classList.remove('hidden');
            ollamaStatus.textContent = `Attendi ${Math.ceil(waitTime/1000)} secondi prima di ricaricare...`;
            ollamaStatus.className = 'text-sm mt-1 text-yellow-600';
            
            // Wait and then try again
            setTimeout(() => loadOllamaModels(), waitTime + 100);
            return;
        }
        
        isLoadingOllamaModels = true;
        
        try {
            // Show loading state
            ollamaStatus.classList.remove('hidden');
            ollamaStatus.textContent = 'Caricamento modelli Ollama...';
            ollamaStatus.className = 'text-sm mt-1 text-blue-600';
            
            // Try to fetch models from Ollama API
            const response = await fetch('http://localhost:11434/api/tags', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                // Use a short timeout to quickly detect if Ollama is not running
                signal: AbortSignal.timeout(5000) // Increased timeout for better reliability
            });
            
            // Update the last request time
            lastOllamaApiRequestTime = Date.now();
            
            if (response.ok) {
                const data = await response.json();
                
                // Clear previous options except the first one
                while (ollamaModelsSelect.options.length > 1) {
                    ollamaModelsSelect.remove(1);
                }
                
                // Add models to select dropdown
                if (data.models && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name;
                        ollamaModelsSelect.appendChild(option);
                    });
                    
                    ollamaStatus.textContent = `${data.models.length} modelli disponibili`;
                    ollamaStatus.className = 'text-sm mt-1 text-green-600';
                    
                    // Select the first model by default if none is selected
                    if (!ollamaModelsSelect.value && ollamaModelsSelect.options.length > 1) {
                        ollamaModelsSelect.selectedIndex = 1;
                    }
                } else {
                    ollamaStatus.textContent = 'Nessun modello trovato. Scarica un modello con il comando "ollama pull <nome-modello>"';
                    ollamaStatus.className = 'text-sm mt-1 text-yellow-600';
                }
            } else if (response.status === 429) {
                // Handle rate limit specifically
                ollamaStatus.textContent = 'Limite di richieste raggiunto. Attendi qualche secondo e riprova.';
                ollamaStatus.className = 'text-sm mt-1 text-yellow-600';
                
                // Try again after a longer delay
                setTimeout(() => loadOllamaModels(), OLLAMA_API_RATE_LIMIT * 2);
            } else {
                throw new Error(`Errore API Ollama: ${response.status}`);
            }
        } catch (error) {
            console.error('Errore nel caricamento dei modelli Ollama:', error);
            
            // Show appropriate error message based on the error
            ollamaStatus.classList.remove('hidden');
            
            if (error.message.includes('Rate limit') || error.message.includes('429')) {
                ollamaStatus.textContent = 'Limite di richieste raggiunto. Attendi qualche secondo e riprova.';
                ollamaStatus.className = 'text-sm mt-1 text-yellow-600';
                
                // Try again after a delay
                setTimeout(() => loadOllamaModels(), OLLAMA_API_RATE_LIMIT * 2);
            } else if (error.name === 'AbortError' || error.name === 'TypeError' || error.message.includes('Failed to fetch')) {
                ollamaStatus.innerHTML = 'Ollama non è in esecuzione. <a href="https://ollama.com/download" target="_blank" class="text-blue-600 underline">Installa Ollama</a> e avvialo per utilizzare i modelli locali.';
                ollamaStatus.className = 'text-sm mt-1 text-red-600';
            } else {
                ollamaStatus.textContent = `Errore: ${error.message}`;
                ollamaStatus.className = 'text-sm mt-1 text-red-600';
            }
        } finally {
            isLoadingOllamaModels = false;
        }
    }

    function startNewChat() {
        // Reset all select elements
        const selects = ['grade-select', 'mode-select', 'subject-select', 'model-select', 'ollama-models-select'];
        selects.forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.selectedIndex = 0;
                select.disabled = false;
            }
        });

        // Nascondi il selettore di modelli Ollama se non è selezionato
        const ollamaModelsSelect = document.getElementById('ollama-models-select');
        const ollamaSelectArrow = document.getElementById('ollama-select-arrow');
        if (ollamaModelsSelect) ollamaModelsSelect.classList.add('hidden');
        if (ollamaSelectArrow) ollamaSelectArrow.classList.add('hidden');

        // Reset context and message inputs
        const contextInput = document.getElementById('context-input');
        const messageInput = document.getElementById('message-input');
        if (contextInput) {
            contextInput.value = '';
            contextInput.disabled = false;
            contextInput.placeholder = 'Descrivi la personalità del bot e il modo in cui dovrà esserti utile....';
        }
        if (messageInput) {
            messageInput.value = '';
            messageInput.disabled = true;
        }

        // Clear chat messages
        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) chatMessages.innerHTML = '';

        // Reset current chat ID
        currentChatId = null;

        // Show the submit button if it was hidden
        const startButton = document.querySelector('button[onclick="submitContext()"]');
        if (startButton) {
            startButton.style.display = '';
            startButton.disabled = false;
        }
        
        // Riabilita tutti i controlli di selezione
        const allInputs = document.querySelectorAll('select, input, textarea');
        allInputs.forEach(input => {
            // Non riabilitare il campo messaggio, che deve rimanere disabilitato fino all'inizio della chat
            if (input.id !== 'message-input') {
                input.disabled = false;
            }
        });
    }

    async function deleteChat(chatId) {
        if (!confirm('Sei sicuro di voler eliminare questa chat?')) return;
        
        try {
            const response = await fetch(`/api/chat/${chatId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            // Refresh chat history
            await loadChatHistory();
            
            // If deleted chat was current chat, start new chat
            if (chatId === currentChatId) {
                startNewChat();
            }
        } catch (error) {
            console.error('Error deleting chat:', error);
            alert('Errore durante l\'eliminazione della chat: ' + error.message);
        }
    }

    async function clearAllChats() {
        if (!confirm('Sei sicuro di voler eliminare tutte le chat? Questa azione non può essere annullata.')) {
            return;
        }
        
        try {
            // Delete all chats from the server
            const response = await fetch('/api/chats', {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            // Reset UI
            document.getElementById('chat-history').innerHTML = '';
            document.getElementById('chat-messages').innerHTML = '';
            
            // Reset selectors
            document.getElementById('grade-select').selectedIndex = 0;
            document.getElementById('mode-select').selectedIndex = 0;
            document.getElementById('subject-select').selectedIndex = 0;
            document.getElementById('model-select').selectedIndex = 0;
            
            // Reset inputs
            document.getElementById('context-input').value = '';
            document.getElementById('message-input').value = '';
            document.getElementById('message-input').disabled = true;
            
            // Hide interview questions if visible
            const interviewQuestions = document.getElementById('interview-questions');
            if (interviewQuestions) {
                interviewQuestions.classList.add('hidden');
                if (document.getElementById('character-input')) {
                    document.getElementById('character-input').value = '';
                }
                if (document.getElementById('historical-accuracy')) {
                    document.getElementById('historical-accuracy').checked = false;
                }
                if (document.getElementById('period-language')) {
                    document.getElementById('period-language').checked = false;
                }
            }
            
            // Reset current chat ID
            currentChatId = null;
            
            // Show and enable the submit button
            const startButton = document.querySelector('button[onclick="submitContext()"]');
            if (startButton) {
                startButton.style.display = '';
                startButton.disabled = false;
            }
            
            // Refresh chat history
            await loadChatHistory();
        } catch (error) {
            console.error('Error clearing all chats:', error);
            alert('Errore durante l\'eliminazione di tutte le chat: ' + error.message);
        }
    }

    async function downloadChat() {
        if (!currentChatId) {
            alert('Nessuna chat da scaricare');
            return;
        }

        try {
            const response = await fetch(`/api/chat/${currentChatId}`);
            const data = await response.json();
            
            // Format chat content
            let content = 'Chat Export\n\n';
            content += `Data: ${new Date().toLocaleString()}\n`;
            content += `Titolo: ${data.settings?.subject || 'Chat'}\n`;
            content += `Modalità: ${data.settings?.mode || 'Standard'}\n`;
            content += `Grado: ${data.settings?.grade || 'Non specificato'}\n\n`;
            
            data.messages.forEach(msg => {
                content += `${msg.role === 'user' ? 'Tu' : 'Bot'}: ${msg.content}\n\n`;
            });
            
            // Create and trigger download
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat_${currentChatId}_${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Error downloading chat:', error);
            alert('Errore durante il download della chat: ' + error.message);
        }
    }

    async function loadChat(chatId) {
        try {
            // Show loading state
            const messagesContainer = document.getElementById('chat-messages');
            messagesContainer.innerHTML = '<div class="loading-message">Caricamento messaggi...</div>';

            const response = await fetch(`/api/chat/${chatId}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Clear loading message and update UI with chat data
            messagesContainer.innerHTML = '';
            if (data.messages && data.messages.length > 0) {
                data.messages.forEach(msg => {
                    if (msg.role && msg.content) {
                        addMessageToUI(msg.role, msg.content);
                    }
                });
            }
            
            // Update current chat ID and history UI
            currentChatId = chatId;
            await loadChatHistory();
            
            // Update settings if available
            if (data.settings) {
                const settings = {
                    'grade-select': data.settings.grade,
                    'mode-select': data.settings.mode,
                    'subject-select': data.settings.subject,
                    'model-select': data.settings.model || 'gpt4',
                    'context-input': data.settings.systemPrompt
                };

                // Update each setting if the element exists
                Object.entries(settings).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.value = value || '';
                    }
                });
            }
        } catch (error) {
            console.error('Error loading chat:', error);
            const messagesContainer = document.getElementById('chat-messages');
            messagesContainer.innerHTML = `<div class="error-message">Errore nel caricamento della chat: ${error.message}</div>`;
        }
    }


</script>

<!-- Event listeners per il tutorial -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Verifica se Ollama è disponibile localmente sul computer dell'utente
        checkLocalOllamaAvailability();
        
        // Apri il modale del tutorial quando si clicca sul link
        document.getElementById('open-tutorial-modal').addEventListener('click', (e) => {
            e.preventDefault();
            const modal = document.getElementById('tutorial-modal');
            modal.classList.remove('hidden');
        });
        
        closeTutorialButton.addEventListener('click', function() {
            tutorialModal.classList.add('hidden');
        });

        // Chiudi il modale del tutorial quando si clicca sul pulsante di chiusura
        document.getElementById('close-tutorial-modal').addEventListener('click', () => {
            const modal = document.getElementById('tutorial-modal');
            modal.classList.add('hidden');
        });

        // Chiudi il modale quando si clicca sul pulsante "Chiudi tutorial"
        document.getElementById('close-tutorial-btn').addEventListener('click', () => {
            const modal = document.getElementById('tutorial-modal');
            modal.classList.add('hidden');
        });

        // Chiudi il modale del tutorial quando si clicca fuori
        document.getElementById('tutorial-modal').addEventListener('click', (e) => {
            if (e.target.id === 'tutorial-modal') {
                document.getElementById('tutorial-modal').classList.add('hidden');
            }
        });

        // Chiudi il modale quando si preme il tasto ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('tutorial-modal');
                if (!modal.classList.contains('hidden')) {
                    modal.classList.add('hidden');
                }
            }
        });
    });
</script>
{% endblock %}
